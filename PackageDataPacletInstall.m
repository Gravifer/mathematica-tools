(* ::Package:: *)


(* ::Title:: *)
(*PackageDataPacletInstall Package*)

(* ::Text::GrayLevel[.5]:: *)
(*Autogenerated  package*)

PDInstallPaclet::usage=
	"Installs a paclet from a site";


Begin["`Private`"];


PDInstallPaclet::howdo="Unsure how to pack a paclet from file type ``";
PDInstallPaclet::laywha="Couldn't detect package layout from directory ``";


PDpacletInfoAssociation[PacletManager`Paclet[k__]]:=
With[{o=Options[PDpacletExpression]},
	KeySortBy[First@FirstPosition[o,#]&]
	]@
With[{base=
		KeyMap[Replace[s_Symbol:>SymbolName[s]],<|k|>]
		},
	ReplacePart[base,
		"Extensions"->
		AssociationThread[
			First/@base["Extensions"],
			Association@*Rest/@base["Extensions"]
			]
		]
	];
PDpacletInfoAssociation[infoFile_]:=
Replace[PDpacletInfo[infoFile],{
		p:PacletManager`Paclet[__]:>
		PDpacletInfoAssociation@p,
		_-><||>
		}];
PDpacletInfo[infoFile_]:=
With[{PDpacletInfo=
		Replace[infoFile,{
				d:(_String|_File)?DirectoryQ:>
				FileNameJoin@{d,"PacletInfo.m"},
				f:(_String|_File)?(FileExtension[#]=="PDpaclet"&):>
				With[{rd=CreateDirectory[]},
					First@ExtractArchive[f,rd,"*PacletInfo.m"]
					]
				}]
		},
	(If[
			StringContainsQ[
				Nest[DirectoryName,PDpacletInfo,3],
				$TemporaryDirectory
				]&&
			(StringTrim[DirectoryName@PDpacletInfo,$PathnameSeparator~~EndOfString]!=
				StringTrim[
					If[DirectoryQ@infoFile,
						infoFile,
						DirectoryName@infoFile],
					$PathnameSeparator~~EndOfString
					]),
			DeleteDirectory[Nest[DirectoryName,PDpacletInfo,2],DeleteContents->True]
			];#)&@
	If[FileExistsQ@PDpacletInfo,
		
		Begin["PacletManager`"];
		(End[];
			Map[
				Replace[#,
					(s_Symbol->v_):>
					(SymbolName[s]->v)
					]&,
				#])&@Import[PDpacletInfo],
		PacletManager`Paclet[]
		]
	];


Options[PDpacletDocsInfo]={
	"Language"->"English",
	"Root"->None,
	"LinkBase"->None,
	"MainPage"->None(*,
	"Resources"\[Rule]None*)
	};
PDpacletDocsInfo[ops:OptionsPattern[]]:=
SortBy[DeleteCases[DeleteDuplicatesBy[{ops},First],_->None],
	With[{o=Options@PDpacletDocsInfo},Position[o,First@#]&]];
PDpacletDocsInfo[dest_String?DirectoryQ,ops:OptionsPattern[]]:=
With[{lang=
		FileBaseName@
		SelectFirst[
			FileNames["*",FileNameJoin@{dest,"Documentation"}],
			DirectoryQ]},
	If[MissingQ@lang,
		{},
		PDpacletDocsInfo[ops,
			"Language"->
			lang,
			"MainPage"->
			Replace[
				Map[
					FileNameTake[#,-2]&,
					Replace[
						FileNames["*.nb",
							FileNameJoin@{dest,"Documentation",lang,"Guides"}],{
							{}:>
							FileNames["*.nb",
								FileNameJoin@{dest,"Documentation",lang},
								2]
							}]
					],{
					{}->None,
					p:{__}:>
					First@
					SortBy[StringTrim[p,".nb"],
						EditDistance[FileBaseName@dest,FileBaseName@#]&]
					}]
			]
		]
	];


Options[PDpacletExtensionData]={
	"Documentation"->Automatic,
	"Kernel"->Automatic,
	"FrontEnd"->Automatic,
	"Resource"->Automatic,
	"AutoCompletionData"->Automatic
	};
PDpacletExtensionData[PDpacletInfo_Association,dest_,ops:OptionsPattern[]]:=
Merge[Merge[Last]]@{
	Replace[Lookup[PDpacletInfo,"Extensions"],
		Except[_Association?AssociationQ]:>
		<||>
		],
	{
		Replace[OptionValue["Documentation"],{
				Automatic:>
				If[Length@
					FileNames["*.nb",
						FileNameJoin@{dest,"Documentation"},
						\[Infinity]]>0,
					"Documentation"->
					PDpacletDocsInfo[dest],
					Nothing
					],
				r:_Rule|{___Rule}:>
				"Documentation"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
		Replace[OptionValue["Kernel"],{
				Automatic:>
				"Kernel"->
				<|
				Root -> ".", 
				Context -> FileBaseName@dest<>"`"
				|>,
				r:_Rule|{___Rule}:>
				"Kernel"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
		Replace[OptionValue["FrontEnd"],{
				Automatic:>
				If[Length@Select[Not@*DirectoryQ]@
					Flatten@Join[
						Map[
							FileNames["*.nb",
								FileNameJoin@{dest,"FrontEnd","Documentation",#},
								\[Infinity]]&,{
								"ReferencePages",
								"Guides",
								"Tutorials"
								}],
						Map[
							FileNames["*",
								FileNameJoin@{dest,"FrontEnd",#},
								\[Infinity]
								]&,{
								"TextResources",
								"SystemResources"
								}]
						]>0,
					"FrontEnd"->
					If[
						DirectoryQ@
						FileNameJoin@{dest,
							"FrontEnd",
							"TextResources"
							}||
						DirectoryQ@
						FileNameJoin@{dest,
							"FrontEnd",
							"SystemResources"
							},
						<|Prepend->True|>,
						<||>
						],
					Nothing
					],
				r:_Rule|{___Rule}:>
				"FrontEnd"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
		Replace[OptionValue["Resource"],{
				Automatic:>
				If[Length@
					Select[
						FileNames["*",
							FileNameJoin@{dest,"Data"},
							\[Infinity]],
						Not@DirectoryQ@#&&
						Not@StringMatchQ[FileNameTake@#,".DS_Store"]&
						]>0,
					"Resource"->
					<|
					"Root" -> "Data",
					"Resources" -> 
					Map[
						FileNameDrop[#,
							FileNameDepth[dest]+1
							]&,
						Select[
							FileNames["*",
								FileNameJoin@{dest,"Data"},
								\[Infinity]],
							Not@DirectoryQ@#&&
							Not@StringMatchQ[FileNameTake@#,".DS_Store"]&
							]
						]
					|>,
					Nothing
					],
				r:_Rule|{___Rule}:>
				"Resource"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}],
		Replace[OptionValue["AutoCompletionData"],{
				Automatic:>
				If[Length@
					FileNames["*.tr"|"documentedContexts.m",
						FileNameJoin@{dest,"AutoCompletionData"},
						\[Infinity]]>0,
					"AutoCompletionData"->
					<|
					"Root" -> "AutoCompletionData"
					|>,
					Nothing
					],
				r:_Rule|{___Rule}:>
				"Documentation"->Association@Flatten@{r},
				Except[_Association]->Nothing
				}]
		}
	};


Options[PDpacletExpression]=
Join[
	{
		"Name"->"MyPaclet",
		"Version"->Automatic,
		"Creator"->Automatic,
		"Description"->Automatic,
		"Root"->Automatic,
		"WolframVersion"->Automatic,
		"Internal"->Automatic,
		"Loading"->Automatic,
		"Qualifier"->Automatic,
		"BuildNumber"->Automatic,
		"Extensions"->Automatic
		},
	Options@PDpacletExtensionData
	];
PDpacletExpression[ops:OptionsPattern[]]:=
PacletManager`Paclet@@
SortBy[DeleteCases[DeleteDuplicatesBy[{ops},First],_->None],
	With[{o=Options@PDpacletExpression},Position[o,First@#]&]
	];


PDpacletExpression[
	dest_String?DirectoryQ,
	ops:OptionsPattern[]]:=
With[{PDpacletInfo=PDpacletInfoAssociation[dest]},
	PDpacletExpression[
		Sequence@@FilterRules[{ops},
			Except["Kernel"|"Documentation"|"Extensions"|"FrontEnd"]],
		"Name"->FileBaseName@dest,
		"Extensions"->
		Replace[OptionValue["Extensions"],{
				Automatic:>
				KeyValueMap[Prepend[Normal@#2,#]&,
					PDpacletExtensionData[PDpacletInfo,
						dest,
						FilterRules[{ops},
							Options@PDpacletExtensionData
							]
						]
					],
				Except[_List]:>
				With[{baseData=
						PDpacletExtensionData[PDpacletInfo,
							dest,
							FilterRules[{ops},
								Options@PDpacletExtensionData
								]
							]},
					Map[
						Replace[OptionValue[#],{
								Automatic:>
								Replace[Lookup[baseData,#],{
										a_Association:>
										Flatten@{#,Normal@a},
										_->Nothing
										}],
								r:_Rule|{___Rule}|_Association:>
								Flatten@{
									#,
									Normal@r
									},
								_->Nothing
								}]&,
						Keys@Options[PDpacletExtensionData]
						]
					]
				}],
		"Version"->
		Replace[OptionValue@"Version",
			Automatic:>
			With[{pointVersions=
					StringSplit[
						ToString[Lookup[PDpacletInfo,"Version","1.0.-1"]],
						"."
						]
					},
				StringJoin@Riffle[
					If[Length@pointVersions>1,
						Append[Most@pointVersions,
							ToString[ToExpression[Last@pointVersions]+1]
							],
						{pointVersions,"1"}],
					"."]
				]
			],
		Sequence@@Normal@PDpacletInfo
		]
	];


Options[PDpacletExpressionBundle]=
Options[PDpacletExpression];
PDpacletExpressionBundle[
	paclet_PacletManager`Paclet,
	dest_String?DirectoryQ]:=
With[{pacletFile=FileNameJoin@{dest,"PacletInfo.m"}},
	Begin["PacletManager`"];
	Block[{$ContextPath={"System`","PacletManager`"}},
		With[{pac=
				Replace[paclet,
					(n_->v_):>(ToExpression[n]->v),
					1]},
			Export[pacletFile,pac]
			]
		];
	End[];
	PDpacletFile
	];
PDpacletExpressionBundle[
	dest_String?DirectoryQ,
	ops:OptionsPattern[]
	]:=
PDpacletExpressionBundle[
	PDpacletExpression[dest,ops],
	dest
	];


PDpacletLookup[p:{__PacletManager`Paclet},props_]:=
Lookup[PacletManager`PacletInformation/@p,props];
PDpacletLookup[p_PacletManager`Paclet,props_]:=
Lookup[PacletManager`PacletInformation@p,props];
PDpacletLookup[p:_String|{_String,_String},props_]:=
PDpacletLookup[PacletManager`PacletFind[p],props];


PDpacletOpen[p_,which:_:First]:=
With[{locs=PDpacletLookup[p,"Location"]},
	With[{files=
			Flatten@{
				Replace[
					which@Flatten@{locs},
					HoldPattern[which[f_]]:>f
					]
				}
			},
		Map[SystemOpen,files];
		files
		]/;
	AllTrue[Flatten@{locs},StringQ]
	];


Options[PDpacletBundle]={
	"RemovePaths"->{},
	"RemovePatterns"->".DS_Store",
	"BuildRoot":>$TemporaryDirectory
	};
PDpacletBundle[dir:(_String|_File)?DirectoryQ,ops:OptionsPattern[]]:=
	With[{PDpacletDir=
			FileNameJoin@{
				OptionValue["BuildRoot"],
				"_PDpaclets",
				FileBaseName@dir
				}
			},
		If[!FileExistsQ@DirectoryName[PDpacletDir],
			CreateDirectory@DirectoryName[PDpacletDir]
			];
		If[FileExistsQ@PDpacletDir,
			DeleteDirectory[PDpacletDir,DeleteContents->True]
			];
		CopyDirectory[dir,PDpacletDir];
		Do[
			With[{p=If[Not@FileExistsQ@path,FileNameJoin@{PDpacletDir,path},path]},
				If[DirectoryQ@p,
					DeleteDirectory[p,
						DeleteContents->True
						],
					If[FileExistsQ@p,DeleteFile[p]]
					]
				],
			{path,
				Join[
					Flatten[{OptionValue["RemovePaths"]},1],
					FileNameDrop[#,FileNameDepth@PDpacletDir]&/@
						FileNames[OptionValue["RemovePatterns"],PDpacletDir,\[Infinity]]
					]}
			];
		With[{PDpacletFile=PacletManager`PackPaclet[PDpacletDir]},
			PDpacletFile
			]
		];


Options[installPacletGenerate]={
	"Verbose"->False
	};


installPacletGenerate[dir:(_String|_File)?DirectoryQ,ops:OptionsPattern[]]:=
Block[{bundleDir=dir},
	If[OptionValue@"Verbose",
		DisplayTemporary@
		Internal`LoadingPanel[
			TemplateApply["Bundling PDpaclet for ``",dir]
			]
		];
	(* ------------ Extract Archive Files --------------- *)
	If[FileExistsQ@#,Quiet@ExtractArchive[#,dir]]&/@
	Map[
		FileNameJoin@{dir,FileBaseName@dir<>#}&,
		{".zip",".gz"}
		];
	(* ------------ Detect Paclet Layout --------------- *)
	Which[
		FileExistsQ@FileNameJoin@{dir,"PacletInfo.m"},
		bundleDir=dir,
		FileExistsQ@FileNameJoin@{dir,FileBaseName[dir]<>".m"}||
		FileExistsQ@FileNameJoin@{dir,FileBaseName[dir]<>".wl"}||
		FileExistsQ@FileNameJoin@{dir,"Kernel","init"<>".m"}||
		FileExistsQ@FileNameJoin@{dir,"Kernel","init"<>".wl"},
		bundleDir=dir;
		PDpacletExpressionBundle[bundleDir],
		FileExistsQ@FileNameJoin@{dir,FileBaseName@dir,"PacletInfo.m"},
		bundleDir=FileNameJoin@{dir,FileBaseName@dir},
		FileExistsQ@FileNameJoin@{dir,FileBaseName@dir,FileBaseName@dir<>".m"},
		bundleDir=FileNameJoin@{dir,FileBaseName@dir};
		PDpacletExpressionBundle[bundleDir],
		FileExistsQ@FileNameJoin@{dir,FileBaseName[dir]<>".nb"},
		Export[
			FileNameJoin@{dir,FileBaseName[dir]<>".m"},
			"(*Open package notebook*)
CreateDocument[
	Import@
		StringReplace[$InputFileName,\".m\"->\".nb\"]
	]",
			"Text"
			];
		bundleDir=dir;
		PDpacletExpressionBundle[bundleDir],
		_,
		Message[PDInstallPaclet::laywha];
		Throw[$Failed]
		];
	PDpacletBundle[bundleDir]
	];


installPacletGenerate[file:(_String|_File)?FileExistsQ,ops:OptionsPattern[]]:=
Switch[FileExtension[file],
	"m"|"wl",
	If[OptionValue@"Verbose",
		DisplayTemporary@
		Internal`LoadingPanel[
			TemplateApply["Bundling PDpaclet for ``",file]
			]
		];
	With[{dir=
			FileNameJoin@{
				$TemporaryDirectory,
				FileBaseName@file
				}
			},
		Quiet@CreateDirectory[dir];
		If[FileExistsQ@
			FileNameJoin@{
				DirectoryName@file,
				"DependencyInfo.m"
				},
			CopyFile[
				FileNameJoin@{
					DirectoryName@file,
					"DependencyInfo.m"
					},
				FileNameJoin@{
					dir,
					"DependencyInfo.m"
					}	
				]
			];
		If[FileExistsQ@
			FileNameJoin@{
				DirectoryName@file,
				"PacletInfo.m"
				},
			CopyFile[
				FileNameJoin@{
					DirectoryName@file,
					"PacletInfo.m"
					},
				FileNameJoin@{
					dir,
					"PacletInfo.m"
					}	
				]
			];
		CopyFile[file,
			FileNameJoin@{
				dir,
				FileNameTake@file
				},
			OverwriteTarget->True
			];
		PDpacletExpressionBundle[dir,
			"Name"->
			StringReplace[FileBaseName[dir],
				Except[WordCharacter|"$"]->""]
			];
		PDpacletBundle[dir,
			"BuildRoot"->$TemporaryDirectory
			]
		],
	"nb",
	With[{dir=
			FileNameJoin@{
				$TemporaryDirectory,
				StringJoin@RandomSample[Alphabet[],10],
				FileBaseName@file
				}
			},
		Quiet[
			DeleteDirectory[dir,DeleteContents->True];
			CreateDirectory[dir,CreateIntermediateDirectories->True]
			];
		CopyFile[file,FileNameJoin@{dir,FileNameTake@file}];
		installPacletGenerate[dir]
		],
	"PDpaclet",
	file,
	_,
	Message[PDInstallPaclet::howdo,
		FileExtension@file
		]
	];


PDgitHubPathQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		MatchQ[p["Scheme"],"http"|"https"]&&
		p["Domain"]=="github.com"&&
		Length@p["Path"]>0
		];
PDgitHubPathQ[_PDgitHubPath]:=
	True;


PDgitHubPathParse[path:_String|_URL]:=
	If[PDgitHubPathQ[path],
		Replace[
			DeleteCases[""]@
				URLParse[path,"Path"],{
			{user_,parts__}|
			{user_,parts__}:>
				PDgitHubPath[parts,"Username"->user]
			}],
		$Failed
		];


PDgitHubReleaseQ[PDgitHubPath[p__String,___?OptionQ]]:=
	MatchQ[{p},
		{__,"releases"}|
		{__,"releases","tag",_}
		];
PDgitHubReleaseQ[path:_String|_URL]:=
	If[PDgitHubPathQ@path,
		Replace[PDgitHubPathParse[path],{
			g_PDgitHubPath:>
				PDgitHubReleaseQ@g,
			_->False
			}],
		False
		];


PDgitHubRepoQ[path:_String|_URL]:=
	With[{p=URLParse[path]},
		MatchQ[p["Scheme"],"http"|"https"]&&
		p["Domain"]=="github.com"&&
		Length@p["Path"]>0&&
		!MatchQ[p["Path"],
			{"repos",__}|
			{__,"releases"|"deployments"}|
			{__,"releases"|"deployments","tag",___}
			]
		];
PDgitHubRepoQ[PDgitHubPath[path__String,___?OptionQ]]:=
	!MatchQ[{path},
		{"repos",__}|
		{__,"releases"|"deployments"}|
		{__,"releases"|"deployments","tag",___}
		];
PDgitHubRepoQ[_]:=False


gitPacletPull[loc:(_String|_URL|_File)]:=
	If[StringContainsQ[URLParse[loc,"PathString"],"releases"],
		Block[{
				release=
				SelectFirst[
					Flatten@{
						Import[
							URLBuild@
							ReplacePart[#,{
									"Domain"->"api.github.com",
									"Path"->
									With[{cleanpath=DeleteCases[#["Path"],""]},
										If[cleanpath[[1]]==="repos",
											cleanpath,
											Prepend[cleanpath,"repos"]
											]
										]
									}]&@URLParse[loc],
							"RawJSON"]},
					KeyMemberQ[#,"assets"]||KeyMemberQ[#,"zipball_url"]&&
						(#["prerelease"]=!=True)&
					]
				},
			If[AssociationQ@release,
				With[{tmp=CreateDirectory[]},
					First@MinimalBy[FileNameDepth]@Select[DirectoryQ]@
					If[KeyMemberQ[release,"assets"]&&Length@release["assets"]>0,
						With[{url=
								release[["assets",-1,"browser_download_url"]]
								},
							ExtractArchive[
								URLDownload[url,
									FileNameJoin@{
										$TemporaryDirectory,
										URLParse[url,"Path"][[-1]]
										}
									],
								tmp
								]
							],
						ExtractArchive[
							URLDownload[
								release["zipball_url"],
								FileNameJoin@{
									$TemporaryDirectory,
									URLParse[release["zipball_url"],"Path"][[-1]]
									}
								],
							tmp
							]
						]
					],
				$Failed
				]
			],
		With[{
				dir=
				FileNameJoin@{
					$TemporaryDirectory,
					DeleteCases[URLParse[loc,"Path"],""][[2]]
					}
				},
			Quiet[
				DeleteDirectory[dir,DeleteContents->True];
				CreateDirectory[dir]
				];
			RunProcess[{"git","clone",loc,dir}];
			dir
			]
		];


wolframLibraryPull[loc:_String|_URL]:=
With[{fileURLs=
		URLBuild@
		Merge[{
				URLParse[loc],
				URLParse[#]
				},
			Replace[DeleteCases[#,None],{
					{s_}:>s,
					{___,l_}:>l,
					{}->None
					}]&
			]&/@
		Cases[
			Import[loc,{"HTML","XMLObject"}],
			XMLElement["a",
				{
					___,
					"href"->link_,
					___},
				{___,
					XMLElement["img",
						{___,"src"->"/images/database/download-icon.gif",___},
						_],
					___}
				]:>link,
			\[Infinity]
			]
		},
	With[{name=
			FileBaseName@
			First@
			SortBy[
				Switch[FileExtension[#],
					"PDpaclet",
					0,
					"zip"|"gz",
					1,
					"wl"|"m",
					2,
					_,
					3
					]&
				][URLParse[#,"Path"][[-1]]&/@fileURLs]
			},
		Quiet@
		DeleteDirectory[
			FileNameJoin@{$TemporaryDirectory,name},
			DeleteContents->True
			];
		CreateDirectory@FileNameJoin@{$TemporaryDirectory,name};
		MapThread[
			RenameFile[
				#,
				FileNameJoin@{$TemporaryDirectory,name,URLParse[#2,"Path"][[-1]]}
				]&,{
				URLDownload[fileURLs,
					FileNameJoin@{$TemporaryDirectory,name}],
				fileURLs
				}];
		FileNameJoin@{$TemporaryDirectory,name}
		]
	]


downloadURLIfExists[urlBase_,{files__},dir_]:=
If[
	MatchQ[0|200]@
	URLSave[
		URLBuild@{urlBase,#},
		FileNameJoin@{
			dir,
			#
			},
		"StatusCode"
		],
	FileNameJoin@{
		dir,
		#
		},
	Quiet@
	DeleteFile@
	FileNameJoin@{
		dir,
		#
		};
	Nothing
	]&/@{files}


Options[PDInstallPaclet]=
{
	"Verbose"->True,
	"InstallSite"->True,
	"InstallDependencies"->
	Automatic,
	"Log"->True
	};
PDInstallPaclet[
	loc:(_String|_File)?FileExistsQ,
	ops:OptionsPattern[]
	]:=
Replace[
	installPacletGenerate[loc,ops],{
		File[f_]|(f_String?FileExistsQ):>
		Replace[PacletManager`PacletInstall@f,
			p_PacletManager`Paclet:>
			With[{deps=
					Replace[OptionValue["InstallDependencies"],{
							Automatic->{"Standard"},
							True->All
							}]
					},
				If[MatchQ[deps,_List|All],
					Flatten@{
						p,
						With[{l=PDpacletLookup[p,"Location"]},
							If[FileExistsQ@FileNameJoin@{l,"DependencyInfo.m"},
								Replace[Import["DependencyInfo.m"],{
										a_Association:>
										Switch[deps,
											All,
											Flatten@
											Map[Map[PDInstallPaclet,#]&,a],
											_,
											Flatten@
											Map[PDInstallPaclet,
												Flatten@Lookup[a,deps,{}]
												]
											],
										l_List:>
										Map[PDInstallPaclet,l]
										}],
								{}
								]
							]
						},
					p
					]
				]
			]
		}];
PDInstallPaclet[
	loc:(_String?(URLParse[#,"Scheme"]=!=None&)|_URL),
	ops:OptionsPattern[]
	]:=
Which[
	URLParse[loc,"Domain"]==="github.com",
	With[{dir=
			If[OptionValue@"Verbose"//TrueQ,
				Monitor[
					gitPacletPull[loc],
					Which[PDgitHubRepoQ@loc,
						Internal`LoadingPanel[
							TemplateApply["Cloning repository at ``",loc]
							],
						PDgitHubReleaseQ@loc,
						Internal`LoadingPanel[
							TemplateApply["Pulling release at ``",loc]
							],
						True,
						Internal`LoadingPanel[
							TemplateApply["Downloading from ``",loc]
							]
						]
					],
				gitPacletPull[loc]
				]
			},
		PDInstallPaclet@dir
		],
	URLParse[loc,"Domain"]==="library.wolfram.com",
	With[{dir=
			If[OptionValue@"Verbose"//TrueQ,
				Monitor[
					wolframLibraryPull[loc],
					Internal`LoadingPanel[
						TemplateApply["Downloading from library.wolfram.com ``",loc]
						]
					],
				gitPacletPull[loc]
				]
			},
		PDInstallPaclet@dir
		],
	True,
	If[
		And[
			OptionValue["InstallSite"]//TrueQ,
			MatchQ[
				Quiet@PDpacletSiteInfo[loc],
				PacletManager`PacletSite[__PacletManager`Paclet]
				]
			],
		PDpacletSiteInstall[loc],
		Switch[URLParse[loc,"Path"][[-1]],
			_?(FileExtension[#]=="PDpaclet"&),
			PDInstallPaclet@URLDownload[loc],
			_?(MatchQ[FileExtension[#],"m"|"wl"]&),
			PDInstallPaclet@
			downloadURLIfExists[
				URLBuild[
					ReplacePart[#,
						"Path"->
						Drop[#Path,-1]
						]&@URLParse[loc]
					],{
					URLParse[loc,"Path"][[-1]],
					"DependencyInfo.m",
					"PacletInfo.m"
					}],
			_,
			Replace[
				Quiet@Normal@PDpacletSiteInfoDataset[loc],{
					Except[{__Association}]:>
					(
						Message[PDInstallPaclet::nopac,loc];
						$Failed
						),
					a:{__Association}:>
					PDInstallPaclet[
						URLBuild@
						Flatten@{
							loc,
							StringJoin@{
								Lookup[Last@SortBy[a,#Version&],{
										"Name",
										"Version"
										}],
								".paclet"
								}
							},
						ops
						]
					}]
			]
		]
	];


End[];



